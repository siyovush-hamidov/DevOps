# <center>Конспекты A1 Стажировка DB/DevOps-2023</center>
![](https://th.bing.com/th/id/OIG.P.hRMK3p95Ag4bl2TNw7?w=1024&h=1024&rs=1&pid=ImgDetMain)

- [Конспекты A1 Стажировка DB/DevOps-2023](#конспекты-a1-стажировка-dbdevops-2023)
- [23 / 11 / 2023](#23--11--2023)
- [Какова история Linux?](#какова-история-linux)
- [Дистрибутивы Linux:](#дистрибутивы-linux)
- [Структура файловой системы Linux](#структура-файловой-системы-linux)
- [Linux vs Windows](#linux-vs-windows)
- [30 / 11 / 2023](#30--11--2023)
- [Руководство (справочная информация)](#руководство-справочная-информация)
- [Навигация](#навигация)
- [Каталоги](#каталоги)
- [Файлы](#файлы)
- [Права доступа](#права-доступа)
- [Что такое перенаправления? \>, \>\>, |](#что-такое-перенаправления---)
- [06 / 12 / 2023](#06--12--2023)
- [Основные команды для редактирования текстовых данных](#основные-команды-для-редактирования-текстовых-данных)
- [  07 / 12 / 2023 ](#--07--12--2023-)
- [Почему процесс называется Daemon?](#почему-процесс-называется-daemon)
- [Какие бывают состояния процессов?](#какие-бывают-состояния-процессов)
- [Что за zombie-состояние?](#что-за-zombie-состояние)
- [Каков жизненный цикл процессов?](#каков-жизненный-цикл-процессов)
- [Каковы основные команды для работы с процессами?](#каковы-основные-команды-для-работы-с-процессами)
- [Что такое MiB Swap?](#что-такое-mib-swap)
- [ 16 / 12 / 2023](#-16--12--2023)
- [Что такое --home?](#что-такое---home)
- [Что за команда --gecos?](#что-за-команда---gecos)
- [Что такое логи? Где они хранятся в linux? Почему они так называются?](#что-такое-логи-где-они-хранятся-в-linux-почему-они-так-называются)
- [Есть ли разница между logs в Linux и Windows?](#есть-ли-разница-между-logs-в-linux-и-windows)
- [Что за команда -aG?](#что-за-команда--ag)
- [ОШИБКА](#ошибка)
- [РЕШЕНИЕ](#решение)
- [Как вывести список всех пользователей?](#как-вывести-список-всех-пользователей)
- [Как войти под именем другого пользователя?](#как-войти-под-именем-другого-пользователя)
- [ОШИБКА](#ошибка-1)
- [РЕШЕНИЕ](#решение-1)
- [Почему перед вводом стоит символ `$`? Что если его не ставить?](#почему-перед-вводом-стоит-символ--что-если-его-не-ставить)
- [Как поменять название созданной группы?](#как-поменять-название-созданной-группы)
- [Что за команда grep? Какие у grep аргументы?](#что-за-команда-grep-какие-у-grep-аргументы)
- [Что за команда last? Какие у last аргументы?](#что-за-команда-last-какие-у-last-аргументы)
- [Зачем в echo стоит параметр -e?](#зачем-в-echo-стоит-параметр--e)
- [Какие еще системные метрики можно вывести? Что насчёт GPU?](#какие-еще-системные-метрики-можно-вывести-что-насчёт-gpu)
- [Какие ресурсы использует Debian из Microsoft Store?](#какие-ресурсы-использует-debian-из-microsoft-store)
- [Database Administration 101 Course](#database-administration-101-course)
- [07 / 01 / 2024 ](#07--01--2024-)
- [Архитектура Oracle Database](#архитектура-oracle-database)
- [Рассмотрим основные файлы Oracle DataBase.](#рассмотрим-основные-файлы-oracle-database)
- [• Файлы данных (datafiles).](#-файлы-данных-datafiles)
- [• Файлы журнала повторного выполнения (redo log files).](#-файлы-журнала-повторного-выполнения-redo-log-files)
- [• Управляющие файлы (control files).](#-управляющие-файлы-control-files)
- [• Временные файлы (temp files).](#-временные-файлы-temp-files)
- [• Файлы параметров.](#-файлы-параметров)
- [Процессы Oracle DataBase.](#процессы-oracle-database)
- [Задание на 07 / 01 / 2024](#задание-на-07--01--2024)
  - [Процесс установки](#процесс-установки)
- [Как изменить пароль пользователя system?](#как-изменить-пароль-пользователя-system)
- [Задание](#задание)
- [Как удалить пользователя system?](#как-удалить-пользователя-system)
- [16 / 01 / 2024](#16--01--2024)
- [Запуск и остановка БД](#запуск-и-остановка-бд)
- [Что такое табличные пространства?](#что-такое-табличные-пространства)
- [Что такое Oracle Network Configuration?](#что-такое-oracle-network-configuration)
- [19 / 01 / 2024 ](#19--01--2024-)
- [Какие бывают расширения файлов в Oracle Database и за что они отвечают?](#какие-бывают-расширения-файлов-в-oracle-database-и-за-что-они-отвечают)
- [Что такое listener?](#что-такое-listener)
- [Что такое экземпляр базы данных и с чем его часто путают?](#что-такое-экземпляр-базы-данных-и-с-чем-его-часто-путают)
- [Финальное задание](#финальное-задание)
- [Как в SQL объявить переменную?](#как-в-sql-объявить-переменную)
- [Как объявить переменную в Linux?](#как-объявить-переменную-в-linux)


# <center><h1>23 / 11 / 2023<h1></center>
# Какова история Linux?

- **Unix - предшественник Linux**: Unix - это операционная система, созданная в 1969 году в США в фирме Bell Laboratories. Она стала основой для многих других систем, в том числе Linux.
- **GNU - свободный софтвер**: GNU - это проект, начатый в 1983 году Ричардом Столлманом, который целился создать полностью свободную операционную систему, совместимую с Unix. Он разработал множество программ и инструментов, которые позже были использованы в Linux.
- **Linux - ядро системы**: Linux - это ядро операционной системы, написанное в 1991 году Линусом Торвальдсом, студентом из Финляндии. Он опубликовал свой код в Интернете и пригласил других программистов присоединиться к разработке. Ядро Linux было сочетано с программами GNU, образуя полноценную операционную систему Linux.
- **Распространение и разнообразие Linux**: Linux стал популярным среди пользователей и разработчиков, так как он был свободным, открытым и гибким. Со временем появилось много различных версий Linux, называемых дистрибутивами, которые адаптировались под разные нужды и предпочтения. Некоторые известные дистрибутивы Linux - это Debian, Ubuntu, Fedora, Red Hat и другие.
# Дистрибутивы Linux:
Вот краткое описание каждого из этих дистрибутивов Linux:

- **Debian**: Это один из самых старых и уважаемых дистрибутивов Linux. Он славится своей стабильностью и безопасностью, а также большим количеством пакетов программного обеспечения.

- **Ubuntu**: Основан на Debian, Ubuntu стал одним из самых популярных дистрибутивов Linux благодаря своей простоте использования и большому сообществу пользователей.

- **Mint**: Linux Mint также основан на Ubuntu и Debian. Он был разработан с целью предоставить более полный и "из коробки" опыт для пользователей, включая поддержку мультимедиа, драйверов и кодеков.

- **Red Hat Enterprise Linux (RHEL)**: Это коммерческий дистрибутив, который фокусируется на стабильности и поддержке для бизнеса. Он широко используется в корпоративной среде.

- **Fedora**: Fedora - это свободный и открытый дистрибутив, спонсируемый Red Hat. Он часто используется для тестирования новых функций, которые впоследствии могут быть включены в RHEL.

- **Slackware**: Это один из самых старых дистрибутивов Linux, который остается верным традиционной философии Unix.

- **Arch Linux**: Arch Linux известен своей простотой и гибкостью. Он предлагает пользователям полный контроль над системой, но это также требует от них более глубоких знаний о работе Linux.
# Структура файловой системы Linux
Эта страница рассказывает о:

- **Файловая система Linux**: это иерархическая структура каталогов и файлов, которая отличается от Windows. В Linux есть единый корневой каталог (/), а не отдельные диски с буквами. В Linux также есть процедура монтирования, которая позволяет подключать устройства к файловой системе.
- **Типы файлов в Linux**: в Linux файлом может быть не только данные, но и директория, устройство, сокет и другие объекты. Файлы различаются по типу, правам доступа, владельцу и группе. Файлы также чувствительны к регистру, то есть Temp.txt и temp.txt - это разные файлы.
- **Структура директорий в Linux**: в Linux существует стандарт FHS (Filesystem Hierarchy Standard), который определяет назначение каждой директории. Например, /bin содержит исполняемые файлы, /etc содержит файлы конфигураций, /home содержит домашние каталоги пользователей и т.д.
- **Различия с Windows**: в Windows программы обычно хранят все файлы в одной папке, а в Linux файлы программы разделяются по каталогам в зависимости от типа. Также в Windows не требуется монтировать устройства, а просто присваивать им буквы.
# Linux vs Windows
Вот более подробный конспект информации с этой страницы:

- **Сравнение Linux и Windows**: Страница начинается с общего сравнения операционных систем Linux и Windows. Основные различия касаются исходного кода (открытый против закрытого), безопасности (Linux обычно считается более безопасным), скорости (Linux обычно быстрее на старом оборудовании), файловой системы (Linux использует иерархическую структуру, в то время как Windows использует буквы дисков), и типов пользователей (в Linux есть больше гибкости в управлении правами пользователей).

- **Файловая система Linux**: В Linux все является файлом - это ключевой принцип, который отличает его от Windows. Это включает в себя не только данные, но и директории, устройства, сокеты и другие объекты. Файлы в Linux различаются по типу, правам доступа, владельцу и группе. Файлы также чувствительны к регистру, то есть Temp.txt и temp.txt - это разные файлы. Страница также перечисляет важные директории в Linux и их назначение, такие как /bin (исполняемые файлы), /etc (файлы конфигурации), /home (домашние каталоги пользователей) и т.д.

- **Файловая система Windows**: В Windows файлы хранятся в папках на разных дисках, таких как C:, D:, E: и т.д. Это отличается от Linux, где есть единый корневой каталог (/). В Windows также есть различные типы учетных записей пользователей, такие как администратор, стандартный, гость и т.д.

- **Сходства и различия между Linux и Mac OS**: Страница утверждает, что переход от Mac OS к Linux будет относительно гладким, так как Mac OS использует ядро UNIX, которое очень похоже на Linux. В то же время, пользователи Windows должны будут привыкнуть к новой системе, так как она существенно отличается.
# <center><h1>30 / 11 / 2023</h1></center>
# Руководство (справочная информация) 
man <utility> # просмотр справочной информации по утилите

<utility> --help # просмотр справочной информации по утилите

# Навигация
ls -la <путь/к/каталогу> # просмотр содержимого каталога (в том числе прав доступа)

cd <путь/к/каталогу> # переход в каталог

# Каталоги 
mkdir <путь/к/каталогу> # создание каталога

rmdir <путь/к/каталогу> # удаление пустого каталога

rm -rf <путь/к/каталогу> # удаление каталога с файлами

# Файлы 
cat <file> # вывод файла в консоль

less <file> # постраничный вывод файла

tail <file> # вывод последних строк («хвоста») файла

vi <file> # редактиврование файла текстовым редактором vi

nano <file> # редактирование файла текстовым редактором nano

cp <file> <путь/к/каталогу> # копирование файла в каталог

mv <file> <путь/к/каталогу> # перемещение файла в каталог (для переименования переместите файл в тот же каталог)

rm <file> # удаление файла

rm -rf <путь/к/каталогу>/* # удаление всех файлов в каталоге

# Права доступа 
chown <user> <путь/к/каталогу> # установить пользователя владельцем каталога

chown <user>:<group> <путь/к/каталогу> # установить владельца и группу владельца каталога

chmod 644 <file> # установить права доступа rw- r-- r-- (чтение и запись для владельца, чтение для группы владельца, чтение для остальных пользователей)

сhmod 740 <file> # установить права доступа rwx r-- --- (чтение, запись и исполнение для владельца, чтение для группы владельца)

chmod u+w <file> # добавить владельцу право на запись файла

 # Что такое перенаправления? >, >>, |
 Перенаправление ввода-вывода — это способ изменить направление вывода и ввода в командной строке. Обычно вывод осуществляется на экран, а ввод — с клавиатуры, но перенаправление ввода-вывода позволяет изменить порядок.

**Символ ">"** используется для перенаправления стандартного вывода в файл. Например, следующая команда перенаправит вывод команды `ls` в файл `output.txt`:

```
ls > output.txt
```

Эта команда создаст файл `output.txt` в текущем каталоге и запишет в него список всех файлов и каталогов в текущем каталоге.

[Image of Результат команды ls > output.txt]

**Символ "»"** используется для перенаправления стандартного вывода в файл, добавляя новый вывод к существующему содержимому файла. Например, следующая команда добавит к файлу `output.txt` список всех файлов и каталогов в каталоге `/etc`:

```
ls /etc >> output.txt
```

Эта команда создаст файл `output.txt`, если он еще не существует, или добавит новый вывод к существующему содержимому файла.

[Image of Результат команды ls /etc >> output.txt]

**Символ "|"** используется для объединения стандартного вывода одной команды со стандартным вводом другой команды. Например, следующая команда сначала выведет список всех файлов в текущем каталоге, а затем перенаправит этот список в программу `wc` для подсчета количества файлов и строк в каждом файле:

```
ls | wc -l
```

Эта команда выведет на экран один номер, представляющий количество файлов в текущем каталоге.

[Image of Результат команды ls | wc -l]

Перенаправление ввода-вывода — это мощный инструмент, который можно использовать для выполнения различных задач в командной строке.
# <center><h1>06 / 12 / 2023<h1></center>
> # <center>Что такое total n при вызове ls? </center>
При выводе команды `ls` строка `total n` представляет собой сводный отчет о размере всех файлов и каталогов, перечисленных в выводе. Число `n` представляет собой общее количество файлов и каталогов в выводе.

Например, следующий вывод команды `ls` показывает, что в текущем каталоге находится 10 файлов и каталогов, общий размер которых составляет 1000 байт:

```
total 10
-rw-r--r-- 1 root root 100 2023-12-06 12:00 file1
-rw-r--r-- 1 root root 200 2023-12-06 12:01 file2
...
```

Строка `total 10` указывает на то, что в выводе перечислено 10 файлов и каталогов. Число 1000 представляет собой общий размер всех файлов и каталогов в выводе.

Символ `n` в строке `total n` может быть заменен на любое другое число. Например, следующий вывод команды `ls` показывает, что в текущем каталоге находится 5 файлов и каталогов, общий размер которых составляет 500 байт:

```
total 5
-rw-r--r-- 1 root root 100 2023-12-06 12:00 file1
-rw-r--r-- 1 root root 200 2023-12-06 12:01 file2
...
```

Строка `total 5` указывает на то, что в выводе перечислено 5 файлов и каталогов. Число 500 представляет собой общий размер всех файлов и каталогов в выводе.

Функция `total` доступна в большинстве операционных систем на основе Unix, включая Linux, macOS и FreeBSD.
# Основные команды для редактирования текстовых данных
Чтобы выделить весь текст из файла в текстовом редакторе nano, нажмите `Ctrl`+`A`.

Чтобы стереть выделенный текст, нажмите `Ctrl`+`K`.

Чтобы отменить последнее действие, нажмите `Ctrl`+`Z`.

Чтобы вставить скопированный текст, нажмите `Ctrl`+`V`.

Вот пример того, как выполнить эти действия:

```
# Откройте файл для редактирования
nano myfile.txt

# Выделите весь текст
Ctrl+A

# Стереть выделенный текст
Ctrl+K

# Отменить последнее действие
Ctrl+Z

# Вставить скопированный текст
Ctrl+V
```

Эти действия будут работать в любом текстовом редакторе, основанном на nano, включая vim, emacs и Kate.

Вот еще несколько полезных советов по работе с текстовыми редакторами в командной строке:

* Чтобы перейти к началу строки, нажмите `Ctrl`+`A`.
* Чтобы перейти к концу строки, нажмите `Ctrl`+`E`.
* Чтобы перейти к предыдущему слову, нажмите `Ctrl`+`B`.
* Чтобы перейти к следующему слову, нажмите `Ctrl`+`F`.
* Чтобы перейти к строке вверх, нажмите `Ctrl`+`P`.
* Чтобы перейти к строке вниз, нажмите `Ctrl`+`N`.
* Чтобы перейти к определенному символу, введите номер символа и нажмите `Enter`.
* Чтобы вставить символ, нажмите `Ins`.
* Чтобы удалить символ, нажмите `Del`.
* Чтобы сохранить файл, нажмите `Ctrl`+`X`.
* Чтобы выйти из редактора, нажмите `Ctrl`+`C`.
> # Задание на 07 / 12 / 2023 
Создать скрипт, который бы при запуске создавал папку с именем mylinux, в ней создавал бы несколько файлов. В одном должен быть список всех пользователей системы. В другом - содержимое папки /etc. В третьем - список всех групп системы. Также в конец каждого файла надо добавить строчку "This was made by ВАШЕ_ИМЯ on ДАТА_ВЫПОЛНЕНИЯ". На занятии запустите скрипт, посмотрю :)
#!/bin/bash

<h3>Создадим папку mylinux</h3>

mkdir mylinux

<h3>Зафиксируем дату выполнения скрипта</h3>

date_of_execution=$(date)

<h3>Надо создать файл для пользователей</h3>
echo "Список пользователей системы" > mylinux/users.txt
cat /etc/passwd >> mylinux/users.txt
echo "Этот скрипт запустил $USER в $date_of_execution" >> mylinux/users.txt

<h3>Содержимое папки /etc</h3>
echo "Содержимое папки /etc" > mylinux/etc.txt
ls -l /etc >> mylinux/etc.txt
echo "Этот скрипт запустил $USER в $date_of_execution" >> mylinux/etc.txt

<h3>Создадим файл groups.txt</h3>
echo "Список групп системы" > mylinux/groups.txt
cat /etc/group >> mylinux/groups.txt
echo "Этот скрипт запустил $USER в $date_of_execution" >> mylinux/groups.txt

# <center><h1>  07 / 12 / 2023 </h1></center>
<h1>Что такое процессы в Linux? Его виды и их функции</h1>
В операционной системе Linux процесс - это программа, которая выполняется в отдельном виртуальном адресном пространстве. Каждый процесс имеет свой собственный набор ресурсов, таких как память, процессорное время, открытые файлы и устройства.

Процессы можно разделить на несколько основных видов:

* **Пользовательские процессы** - это процессы, запущенные пользователем. Они выполняются в интерактивном режиме и взаимодействуют с пользователем через терминал или графический интерфейс.
* **Системные процессы** - это процессы, запущенные ядром операционной системы. Они выполняют важные системные задачи, такие как управление памятью, процессором и устройствами.
* **Демон-процессы** - это системные процессы, которые выполняются в фоновом режиме. Они выполняют задачи, которые не требуют взаимодействия с пользователем, например, обслуживание сети, базы данных или файловой системы.

**Функции процессов в Linux**

Процессы выполняют различные функции в операционной системе Linux. Они могут:

* Выполнять программы пользователя.
* Запускать другие процессы.
* Обращаться к системным ресурсам, таким как память, процессорное время и устройства.
* Обмениваться данными друг с другом.

Процессы играют важную роль в работе операционной системы Linux. Они обеспечивают выполнение различных задач, необходимых для нормального функционирования системы.

**Примеры процессов в Linux**

Вот некоторые примеры процессов в Linux:

* **Bash** - процесс, который выполняет оболочку пользователя.
* **Gedit** - процесс, который запускается при запуске текстового редактора Gedit.
* **Firefox** - процесс, который запускается при запуске веб-браузера Firefox.
* **Apache** - демон-процесс, который обслуживает веб-сайты.
* **MySQL** - демон-процесс, который обеспечивает работу базы данных MySQL.

Процессы можно создавать, управлять и уничтожать с помощью системных вызовов. В Linux для управления процессами используется набор команд, таких как `ps`, `kill` и `top`.
# Почему процесс называется Daemon?
Термин "демон" (daemon) для описания фоновых процессов в операционных системах впервые был использован программистами проекта MAC Массачусетского технологического института в 1960-х годах. Он был выбран в качестве отсылки к персонажу мысленного эксперимента, демону Максвелла, который, согласно теории вероятности, может сортировать молекулы в замкнутой системе, не нарушая второго закона термодинамики.

Демон Максвелла является метафорой для фонового процесса, который выполняет определенную задачу, не взаимодействуя с пользователем или другими процессами. Он невидим и не требует внимания, но его работа необходима для нормального функционирования системы.

Термин прижился и стал общепринятым в операционных системах Unix и Unix-подобных системах. Традиционно названия демон-процессов заканчиваются на букву d, чтобы показать, что этот процесс является демоном, и для различия нормальной компьютерной программы и демона.

Вот некоторые примеры демон-процессов:

* **init** - процесс, который запускается при загрузке системы и отвечает за запуск других процессов.
* **crond** - процесс, который периодически выполняет задачи, заданные в расписании.
* **sshd** - процесс, который обеспечивает доступ к системе по протоколу SSH.
* **apache** - процесс, который обслуживает веб-сайты.
* **mysqld** - процесс, который обеспечивает работу базы данных MySQL.

Демон-процессы играют важную роль в работе операционных систем. Они обеспечивают выполнение фоновых задач, необходимых для нормального функционирования системы.
# Какие бывают состояния процессов?
В операционной системе Linux процесс может находиться в одном из следующих состояний:

* **Создание (New)** - процесс только что создан и еще не начал выполняться.
* **Готовность (Ready)** - процесс готов к выполнению, но не выполняется в данный момент.
* **Выполняется (Running)** - процесс выполняется в данный момент и использует процессорное время.
* **Ожидание (Waiting)** - процесс ожидает наступления некоторого события, например, завершения другого процесса или поступления данных из устройства.
* **Приостановка (Stopped)** - процесс приостановлен и не использует никаких системных ресурсов.
* **Завершение (Terminated)** - процесс завершен и больше не существует.

**Состояние создания**

Процесс находится в состоянии создания, когда он только что создан и еще не начал выполняться. В этом состоянии процесс выполняет инициализацию и подготовку к выполнению.

**Состояние готовности**

Процесс находится в состоянии готовности, когда он готов к выполнению, но не выполняется в данный момент. В этом состоянии процесс ожидает выделения ему процессорного времени.

**Состояние выполнения**

Процесс находится в состоянии выполнения, когда он выполняется в данный момент и использует процессорное время. В этом состоянии процесс выполняет код программы, на которой он запущен.

**Состояние ожидания**

Процесс находится в состоянии ожидания, когда он ожидает наступления некоторого события, например, завершения другого процесса или поступления данных из устройства. В этом состоянии процесс не использует никаких системных ресурсов, кроме памяти.

**Состояние приостановки**

Процесс находится в состоянии приостановки, когда он приостановлен и не использует никаких системных ресурсов. В этом состоянии процесс может быть возобновлен с помощью системного вызова `continue`.

**Состояние завершения**

Процесс находится в состоянии завершения, когда он завершен и больше не существует. В этом состоянии все ресурсы, выделенные процессу, освобождаются.

**Переход между состояниями**

Процесс может переходить из одного состояния в другое. Переход между состояниями происходит в результате выполнения определенных событий или действий.

Например, процесс может перейти из состояния создания в состояние готовности, когда он завершит инициализацию. Процесс может перейти из состояния готовности в состояние выполнения, когда ему будет выделено процессорное время. Процесс может перейти из состояния выполнения в состояние ожидания, когда он столкнется с ситуацией, требующей ожидания другого процесса или события. Процесс может перейти из состояния ожидания в состояние готовности, когда событие, на которое он ждал, произойдет. Процесс может перейти из состояния готовности в состояние завершения, когда он завершит выполнение своей задачи.

Управление состояниями процессов осуществляется ядром операционной системы. Ядро отслеживает состояние каждого процесса и выполняет необходимые действия для перехода процессов из одного состояния в другое.
# Что за zombie-состояние?
В операционной системе Linux процесс находится в состоянии зомби (zombie), когда он завершил свое выполнение, но его родительский процесс еще не прочитал код завершения дочернего процесса. В этом состоянии процесс не использует никаких системных ресурсов, кроме памяти.

Процесс переходит в состояние зомби, когда он завершает свое выполнение и отправляет родительскому процессу сигнал о завершении. Родительский процесс может прочитать код завершения дочернего процесса с помощью системного вызова `waitpid`. Если родительский процесс не читает код завершения дочернего процесса, то дочерний процесс остается в состоянии зомби.

Зомби-процессы могут быть проблемой для системы, так как они занимают место в таблице процессов. Для того чтобы избежать этой проблемы, родительский процесс должен своевременно читать код завершения дочерних процессов.

В Linux для обнаружения зомби-процессов используется команда `ps`. В выводе команды `ps` зомби-процессы отображаются с символом `<defunct>` в столбце `STAT`.

Для уничтожения зомби-процессов используется команда `kill`. Команда `kill` может быть использована для отправки сигнала родительскому процессу зомби-процесса. После получения сигнала родительский процесс может завершить себя или дочерний процесс.

Вот пример вывода команды `ps`:

```
USER   PID   PPID   VSZ   RSS   TTY      STAT   TIME CMD
root    1     0     1424   984   tty1     Ss     0:00 /bin/bash
root    2     1     0      0     tty1     S      0:00 ps
```

В этом примере процесс с PID 2 является зомби-процессом.
# Каков жизненный цикл процессов?
Жизненный цикл процесса - это последовательность состояний, через которые проходит процесс в течение своего существования. Он начинается с момента создания процесса и заканчивается его завершением.

График жизненного цикла процесса может быть представлен в виде следующей диаграммы:

[Image of Диаграмма жизненного цикла процесса]

На диаграмме показаны следующие состояния процесса:

* **Создание (New)** - процесс только что создан и еще не начал выполняться.
* **Готовность (Ready)** - процесс готов к выполнению, но не выполняется в данный момент.
* **Выполняется (Running)** - процесс выполняется в данный момент и использует процессорное время.
* **Ожидание (Waiting)** - процесс ожидает наступления некоторого события, например, завершения другого процесса или поступления данных из устройства.
* **Приостановка (Stopped)** - процесс приостановлен и не использует никаких системных ресурсов.
* **Завершение (Terminated)** - процесс завершен и больше не существует.

Переход между состояниями процесса может происходить в результате выполнения определенных событий или действий. Например, процесс может перейти из состояния создания в состояние готовности, когда он завершит инициализацию. Процесс может перейти из состояния готовности в состояние выполнения, когда ему будет выделено процессорное время. Процесс может перейти из состояния выполнения в состояние ожидания, когда он столкнется с ситуацией, требующей ожидания другого процесса или события. Процесс может перейти из состояния ожидания в состояние готовности, когда событие, на которое он ждал, произойдет. Процесс может перейти из состояния готовности в состояние завершения, когда он завершит выполнение своей задачи.

Управление состояниями процессов осуществляется ядром операционной системы.
# Каковы основные команды для работы с процессами?
В операционной системе Linux для работы с процессами используется набор команд. Основные команды для работы с процессами следующие:

* **ps** - выводит информацию о запущенных процессах.
* **kill** - посылает сигнал процессу.
* **top** - отображает список запущенных процессов в реальном времени.
* **pgrep** - ищет процессы по имени или по шаблону.
* **pkill** - посылает сигнал всем процессам, которые соответствуют заданному критерию.

**Команда ps**

Команда `ps` выводит информацию о запущенных процессах. Вывод команды `ps` содержит следующие столбцы:

* **PID** - идентификатор процесса.
* **TTY** - терминал, к которому привязан процесс.
* **STAT** - состояние процесса.
* **TIME** - время работы процесса.
* **CMD** - команда, которая запустила процесс.

Вот пример вывода команды `ps`:

```
USER   PID   PPID   VSZ   RSS   TTY      STAT   TIME CMD
root    1     0     1424   984   tty1     Ss     0:00 /bin/bash
root    2     1     0      0     tty1     S      0:00 ps
```

В этом примере процесс с PID 1 является родительским процессом процесса с PID 2.

**Команда kill**

Команда `kill` посылает сигнал процессу. Сигналы используются для управления процессами. Существуют различные типы сигналов, каждый из которых выполняет свое действие.

Для того чтобы послать сигнал процессу, необходимо указать идентификатор процесса (PID) и тип сигнала. Например, для того чтобы завершить процесс с PID 1, необходимо выполнить следующую команду:

```
kill 1
```

**Команда top**

Команда `top` отображает список запущенных процессов в реальном времени. Команда `top` позволяет просматривать информацию о процессах, таких как их состояние, использование процессорного времени, памяти и других ресурсов.

**Команда pgrep**

Команда `pgrep` ищет процессы по имени или по шаблону. Например, для того чтобы найти процессы, которые начинаются с префикса "firefox", необходимо выполнить следующую команду:

```
pgrep firefox
```

**Команда pkill**

Команда `pkill` посылает сигнал всем процессам, которые соответствуют заданному критерию. Например, для того чтобы завершить все процессы, которые начинаются с префикса "firefox", необходимо выполнить следующую команду:

```
pkill firefox
```
# Что такое MiB Swap?
MiB Swap - это количество памяти, выделенной для свопа, в единицах MiB (мегабайт). Свап - это часть жесткого диска, которая используется в качестве виртуальной памяти, когда физическая память исчерпана.

В операционной системе Linux своп обычно представляет собой отдельную раздел или файл. Размер свопа определяется пользователем или автоматически системой.

MiB Swap - это важный параметр системы, который влияет на ее производительность. Если размер свопа слишком мал, это может привести к тому, что система будет часто использовать жесткий диск, что приведет к снижению производительности.

Чтобы проверить размер свопа в Linux, можно использовать команду `free`. Команда `free` выводит информацию о памяти, включая количество памяти, выделенной для свопа.

Вот пример вывода команды `free`:

```
              total        used        free      shared  buff/cache   available
Mem:        16384        12288        1248         144        2848        2256
Swap:       20480        12288        8200
```

В этом примере размер свопа составляет 20480 MiB, из которых 12288 MiB используются и 8200 MiB свободны.

Размер свопа следует выбирать с учетом предполагаемого использования системы. Для систем с небольшим количеством оперативной памяти рекомендуется выделить для свопа не менее 100% от объема оперативной памяти. Для систем с большим количеством оперативной памяти размер свопа можно уменьшить.
# <center><h1> 16 / 12 / 2023</h1></center>
> # Финальное практическое задание для Linux 101.

> - # Cоздать пользователя cerberus. Пользователь должен иметь полное имя Cerberus The Guardian, иметь свою домашнюю директорию, иметь права администратора.

1. Создадим нового пользователя с именем 'cerberus' и полным именем 'Cerberus The Guardian':
```bash
sudo adduser --home /home/cerberus --gecos "Cerberus The Guardian" cerberus
```
2. Зададим пароль для нового пользователя:
```bash
sudo passwd cerberus
```
3. Добавим пользователя 'cerberus' в группу 'sudo' для предоставления ему прав администратора:
```bash
sudo usermod -aG sudo cerberus
```
# Что такое --home?
Опция `--home` в команде `adduser` в Linux используется для указания домашней директории для нового пользователя. 

Домашняя директория - это место в файловой системе, где пользователь может хранить свои личные файлы и настройки. Обычно она находится в `/home/имя_пользователя`.

В вашем примере `--home /home/cerberus` указывает, что домашняя директория нового пользователя 'cerberus' должна быть `/home/cerberus`.

Если опция `--home` не указана при создании нового пользователя, будет создана домашняя директория по умолчанию, обычно `/home/имя_пользователя`.

Надеюсь, это помогло! Если у вас есть еще вопросы, не стесняйтесь задавать.
# Что за команда --gecos?
Команда `--gecos` используется в Linux для установки информации о пользователе, такой как его полное имя, номер комнаты, номер телефона и другие данные. Эта информация обычно отображается в различных системных отчетах и логах.

Слово `gecos` является акронимом и происходит от **G**eneral **E**lectric **C**omprehensive **O**perating **S**upervisor, который был операционной системой, разработанной General Electric в 1960-х годах. В этой системе было поле, называемое GECOS, которое использовалось для хранения дополнительной информации о пользователях. Это поле было перенесено в Unix, и с тех пор оно используется в различных Unix-подобных системах, включая Linux.

В контексте команды `adduser`, опция `--gecos` используется для установки этой информации при создании нового пользователя. Например, в команде `sudo adduser --home /home/cerberus --gecos "cerberus The Guardian" cerberus`, `"cerberus The Guardian"` будет установлено как полное имя пользователя 'cerberus'.
# Что такое логи? Где они хранятся в linux? Почему они так называются?
Логи в операционных системах, таких как Linux, это файлы, которые содержат записи о различных событиях, происходящих в системе. Они включают информацию о запуске и остановке служб, ошибки, предупреждения, информационные сообщения и другие события, которые могут быть полезны для администраторов системы при отладке проблем или мониторинге активности системы.

В большинстве систем Linux лог-файлы хранятся в каталоге `/var/log`. В этом каталоге вы найдете различные файлы и подкаталоги, каждый из которых содержит логи для определенной службы или аспекта системы.

Слово "лог" происходит от "logbook" (журнал), который исторически использовался на кораблях для записи различных событий во время плавания. Этот термин был перенесен в область компьютеров и теперь используется для обозначения файлов, которые содержат записи о событиях, происходящих в компьютерной системе. 

Надеюсь, это помогло! Если у вас есть еще вопросы, не стесняйтесь задавать.
# Есть ли разница между logs в Linux и Windows?
Да, существуют некоторые ключевые различия между логами в Linux и Windows:

1. **Местоположение логов**: В Linux логи обычно хранятся в каталоге `/var/log`, тогда как в Windows логи событий можно просмотреть через инструмент "Просмотр событий" (Event Viewer).

2. **Формат логов**: Логи в Linux обычно представляют собой простые текстовые файлы, которые можно просмотреть и анализировать с помощью стандартных текстовых редакторов и инструментов командной строки. В Windows же логи событий представлены в бинарном формате и требуют специального инструмента для просмотра, такого как "Просмотр событий".

3. **Структура логов**: В Linux логи обычно разделены по приложениям или службам, каждое из которых имеет свой собственный лог-файл (например, `/var/log/apache2/` для Apache). В Windows все события записываются в общие журналы, такие как "Система", "Безопасность" и "Приложение", хотя некоторые приложения могут иметь свои собственные журналы событий.

4. **Ротация логов**: В Linux есть система ротации логов, которая автоматически архивирует старые логи и удаляет самые старые, чтобы сохранить использование дискового пространства. В Windows журналы событий имеют фиксированный размер, и когда они заполняются, новые события либо перезаписывают старые, либо не записываются, в зависимости от настроек.

Надеюсь, это помогло! Если у вас есть еще вопросы, не стесняйтесь задавать.
# Что за команда -aG?
Команда `-aG` используется с командой `usermod` в Linux, которая используется для изменения настроек учетной записи пользователя. Вот что означает каждый флаг:

- `-a`: Этот флаг означает 'append' (добавить). Он используется для добавления пользователя к дополнительной группе без удаления его из текущих групп.

- `G`: Этот флаг используется для указания группы, к которой нужно добавить пользователя.

Таким образом, команда `usermod -aG` используется для добавления пользователя к дополнительной группе. Например, команда `sudo usermod -aG sudo cerberus` добавляет пользователя 'cerberus' в группу 'sudo', что дает ему права администратора. 

Надеюсь, это помогло! Если у вас есть еще вопросы, не стесняйтесь задавать.
>- # Создать скрипт под названием user_check.sh. Владельцем скрипта должен быть root, группа скрипта должна быть watchers. Владелец скрипта должен иметь права на чтение, запись и исполнение. Точно такие же права должны иметь те, кто входят в группу watchers. Остальные не должны иметь никаких прав на скрипт.
1. Создадим файл скрипта с именем `user_check.sh` в домашней директории пользователя 'cerberus':
```bash
sudo touch /home/cerberus/user_check.sh
```
2. Изменим владельца файла на `root`:
```bash
sudo chown root /home/cerberus/user_check.sh
```
3. Изменим группу файла на `watchers`:
```bash
sudo chgrp watchers /home/cerberus/user_check.sh
```
4. Установим права на файл для владельца (root), группы (watchers) и остальных:
```bash
sudo chmod 770 /home/cerberus/user_check.sh
```
# ОШИБКА
siyovush@SIYOVUSH-PC:~$ cd /home/cerberus
-bash: cd: /home/cerberus: Permission denied

# РЕШЕНИЕ
Сообщение об ошибке "Permission denied" (доступ запрещен) указывает на то, что у вас нет прав доступа к директории `/home/cerberus`. Это может быть связано с тем, что вы пытаетесь получить доступ к домашней директории другого пользователя, и у вас нет соответствующих прав.

Если вы действительно хотите получить доступ к этой директории, вам может потребоваться использовать команду `sudo`, которая позволяет выполнять команды с правами суперпользователя. Например:

```bash
sudo cd /home/cerberus
```

Однако, учтите, что использование `sudo` должно быть осторожным, так как это дает вам полный доступ к системе и может привести к необратимым изменениям. Всегда убедитесь, что вы знаете, что делаете, прежде чем использовать `sudo`.

Также стоит отметить, что команда `cd` не работает с `sudo` в bash из-за того, что `cd` является встроенной командой оболочки, а не отдельной программой. Если вам действительно нужно перейти в директорию, к которой у вас нет доступа, вы можете запустить новый шелл с правами суперпользователя с помощью `sudo bash`, а затем использовать `cd`.

Надеюсь, это помогло! Если у вас есть еще вопросы, не стесняйтесь задавать.

# Как вывести список всех пользователей?
В системе Debian вы можете получить список всех пользователей, просмотрев файл `/etc/passwd`, который содержит информацию о каждом пользователе системы. Вот как это сделать:

```bash
cut -d: -f1 /etc/passwd
```

Эта команда выведет список имен всех пользователей. Здесь `cut` - это команда, которая разделяет строки на части, `-d:` указывает, что разделителем является двоеточие, а `-f1` указывает, что мы хотим вывести первое поле (то есть имя пользователя).

Пожалуйста, учтите, что в этом списке будут включены все системные пользователи, а также обычные пользователи. Если вы хотите увидеть только обычных пользователей, вам потребуется более сложная команда или скрипт.

Надеюсь, это помогло! Если у вас есть еще вопросы, не стесняйтесь задавать.
# Как войти под именем другого пользователя?
В Linux вы можете войти под именем другого пользователя с помощью команды `su` (от англ. substitute user). Вот как это сделать:

```bash
su имя_пользователя
```

После выполнения этой команды вам будет предложено ввести пароль пользователя, под которым вы хотите войти.

Также есть команда `sudo`, которая позволяет выполнять отдельные команды от имени другого пользователя. Например, если вы хотите выполнить команду `ls /root` от имени пользователя `root`, вы можете сделать это так:

```bash
sudo -u root ls /root
```

Пожалуйста, будьте осторожны при использовании этих команд, особенно при входе под именем `root`, так как это дает вам полный доступ к системе.

Надеюсь, это помогло! Если у вас есть еще вопросы, не стесняйтесь задавать.
# ОШИБКА
cerberus@SIYOVUSH-PC:~$ sudo chgrp watchers /home/cerberus/u
ser_check.sh
chgrp: invalid group: 'watchers'
# РЕШЕНИЕ
Сообщение об ошибке говорит о том, что группа 'watchers' не существует в вашей системе. Вы можете создать эту группу с помощью команды `groupadd`:

```bash
sudo groupadd watchers
```

После того как группа будет создана, вы сможете изменить группу файла на 'watchers' с помощью команды `chgrp`:

```bash
sudo chgrp watchers /home/cerberus/user_check.sh
```

Пожалуйста, учтите, что вам потребуются права администратора для выполнения этих команд. Если у вас возникнут проблемы или вопросы, не стесняйтесь спрашивать.
# Почему перед вводом стоит символ `$`? Что если его не ставить?
Символ `$` в командной строке Linux обычно указывает на приглашение к вводу команды в оболочке (shell). Он служит визуальным указателем на то, что система готова принять следующую команду.

В контексте командной строки Linux, `$` обычно означает, что вы вошли в систему как обычный пользователь, в отличие от `#`, который указывает, что вы вошли в систему как суперпользователь или 'root'.

Также стоит отметить, что приглашение к вводу команды может быть настроено пользователем и может отображать другую информацию, такую как имя пользователя, имя хоста, текущий каталог и так далее.

Если вы не вводите символ `$` перед командой, это не повлияет на выполнение команды. Однако, если символ `$` используется внутри команды для обозначения переменной окружения (например, $PATH), то его опускание приведет к другому результату, потому что команда будет искать литеральное значение, а не значение переменной.

Надеюсь, это помогло! Если у вас есть еще вопросы, не стесняйтесь задавать.
# Как поменять название созданной группы?
В Linux, чтобы изменить имя группы, вы можете использовать команду `groupmod`. Вот пример использования:

```bash
sudo groupmod -n новое_имя_группы старое_имя_группы
```

В этой команде:
- `sudo` используется для выполнения команды с правами администратора.
- `groupmod` - это команда для модификации группы.
- `-n новое_имя_группы` указывает новое имя для группы.
- `старое_имя_группы` - это текущее имя группы, которое вы хотите изменить.

Пожалуйста, учтите, что вам потребуются права администратора для выполнения этой команды. Будьте осторожны при использовании этой команды, так как это может повлиять на пользователей, которые в настоящее время являются членами этой группы. 

Если у вас есть еще вопросы, не стесняйтесь задавать. 😊
>- # Скрипт user_check.sh должен отображать информацию о пользователе, который его запускает: запись пользователя из /etc/passwd, информацию о времени логина, в каких группах состоит пользователь, содержание домашней директории . Скрипт надо снабдить подробными комментариями.
Откроем файл user_check.sh
```bash
nano /home/cerberus/user_check.sh
```
```bash
#!/bin/bash

# Получаем имя пользователя, который запустил скрипт
user=$(whoami)

echo "Информация о пользователе $user:"

# Выводим запись пользователя из /etc/passwd
echo -e "\nЗапись пользователя из /etc/passwd:"
grep "^$user:" /etc/passwd

# Выводим информацию о времени логина пользователя
echo -e "\nИнформация о времени логина:"
last -n 1 $user

# Выводим группы, в которых состоит пользователь
echo -e "\nГруппы, в которых состоит пользователь:"
groups $user

# Выводим содержание домашней директории пользователя
echo -e "\nСодержание домашней директории:"
ls -la /home/$user
```

Этот скрипт сначала получает имя пользователя, который запустил скрипт, затем выводит его запись из файла `/etc/passwd`, информацию о времени его последнего входа в систему, группы, в которых он состоит, и содержание его домашней директории.

Пожалуйста, учтите, что этот скрипт может требовать прав администратора для доступа к некоторой информации. Если у вас возникнут проблемы или вопросы, не стесняйтесь спрашивать.
# Что за команда grep? Какие у grep аргументы?
Команда `grep` в Linux является мощным инструментом для поиска текста в файлах. Она используется для поиска строк, которые соответствуют заданному шаблону.

Название `grep` происходит от команды `g/re/p` в редакторе `ed`, которая означает "глобально искать регулярное выражение и печатать". 

Вот пример использования команды `grep`:

```bash
grep "поисковый шаблон" имя_файла
```

Эта команда найдет и выведет все строки из файла `имя_файла`, которые содержат `поисковый шаблон`.

Команда `grep` также поддерживает множество опций, которые позволяют настраивать ее поведение, например, `-i` для игнорирования регистра, `-r` для рекурсивного поиска в директориях, `-v` для вывода строк, которые не соответствуют шаблону, и многие другие.

Команда `grep` в Linux имеет множество аргументов, которые позволяют настраивать ее поведение. Вот некоторые из наиболее часто используемых:

- `-i`: Игнорировать регистр при поиске. Например, `grep -i "пример" файл` найдет "Пример", "ПРИМЕР", "прИмЕр" и т.д.
- `-v`: Инвертировать поиск, то есть выводить строки, которые **не** соответствуют шаблону.
- `-r` или `-R`: Рекурсивный поиск, то есть поиск в файлах в указанной директории и всех ее поддиректориях.
- `-l`: Выводить только имена файлов, в которых найдено совпадение (вместо самих совпадающих строк).
- `-n`: Выводить номера строк вместе с совпадающими строками.
- `-c`: Выводить только количество совпадающих строк в каждом файле.
- `-e`: Указывает шаблон для поиска. Это полезно, если шаблон начинается с `-`.
- `-f`: Получает шаблоны для поиска из указанного файла.
- `-w`: Искать только целые слова, соответствующие шаблону.

Это лишь некоторые из доступных аргументов. Для получения полного списка аргументов и их описаний вы можете обратиться к странице справки `grep`, выполнив команду `man grep` в терминале.

Надеюсь, это помогло! Если у вас есть еще вопросы, не стесняйтесь задавать.
# Что за команда last? Какие у last аргументы?
Команда `last` в Linux используется для просмотра истории входа в систему пользователей. Она читает данные из файла `/var/log/wtmp` и выводит список последних входов в систему для всех пользователей в обратном порядке (начиная с самого последнего).

Вот некоторые из наиболее часто используемых аргументов для команды `last`:

- `-n` или `--lines <число>`: Отображает указанное количество строк. Например, `last -n 5` покажет последние 5 входов в систему.
- `-f` или `--file <файл>`: Читает данные из указанного файла, а не из `/var/log/wtmp`.
- `-R`: Не показывает имя хоста в выводе.
- `-i`: Отображает IP-адрес вместо имени хоста.
- `-a`: Выводит имя хоста в последнем столбце. Это полезно для определения местоположения пользователя.

Пример использования команды `last`:

```bash
last -n 10
```

Эта команда покажет последние 10 входов в систему.

Надеюсь, это помогло! Если у вас есть еще вопросы, не стесняйтесь задавать.
>- # Создать скрипт под названием system_monitor.sh. Владельцем скрипта должен быть root, группа скрипта должна быть watchers. Владелец скрипта должен иметь права на чтение, запись и исполнение. Точно такие же права должны иметь те, кто входят в группу watchers. Остальные не должны иметь никаких прав на скрипт.
1. Создадим файл скрипта с именем `system_monitor.sh` в домашней директории пользователя 'cerberus':
```bash
sudo touch /home/cerberus/system_monitor.sh
```
2. Изменим владельца файла на `root`:
```bash
sudo chown root /home/cerberus/system_monitor.sh
```
3. Изменим группу файла на `watchers`:
```bash
sudo chgrp watchers /home/cerberus/system_monitor.sh
```
4. Установим права на файл для владельца (root), группы (watchers) и остальных:
```bash
sudo chmod 770 /home/cerberus/system_monitor.sh
```
>- # Скрипт system_monitor.sh должен отображать информацию о состоянии системы. Обязательно надо отобразить, сколько места остается на жестких дисках, 10 самых ресурсоемких процесса, первые 5 строк выдачи команды top, информацию об оперативной памяти. Также, опционально можно отображать и другие системные метрики - на ваш выбор . Скрипт надо снабдить подробными комментариями.
```bash
#!/bin/bash

# Выводим информацию о свободном и занятом месте на жестких дисках
echo "Информация о дисковом пространстве:"
df -h

# Выводим 10 самых ресурсоемких процессов
echo -e "\n10 самых ресурсоемких процессов:"
ps aux --sort=-%mem | head -n 11

# Выводим первые 5 строк выдачи команды top
echo -e "\nПервые 5 строк выдачи команды top:"
top -b -n 1 | head -n 5

# Выводим информацию об оперативной памяти
echo -e "\nИнформация об оперативной памяти:"
free -h

# Выводим информацию о загрузке процессора
echo -e "\nИнформация о загрузке процессора:"
uptime

# Дополнительные метрики
# Информация о ЦП:
echo -e "\nИнформация о процессоре"
lscpu

# ГП
echo -e "\nИнформация о видеокарте"
lspci | grep VGA

# ОЗУ
echo -e "\nИнформация об оперативной памяти"
sudo dmidecode --type memory
```

Этот скрипт сначала выводит информацию о свободном и занятом месте на жестких дисках, затем 10 самых ресурсоемких процессов, первые 5 строк выдачи команды `top`, информацию об оперативной памяти и информацию о загрузке процессора и дополнительные метрики.
# Зачем в echo стоит параметр -e?
Параметр `-e` в команде `echo` в Linux позволяет интерпретировать управляющие символы, начинающиеся с обратного слэша (`\`). 

Вот некоторые из управляющих символов, которые можно использовать с `echo -e`:

- `\n`: новая строка
- `\t`: горизонтальная табуляция
- `\v`: вертикальная табуляция
- `\b`: возврат на одну позицию назад
- `\r`: возврат каретки
- `\c`: подавить последующий вывод

Например, команда `echo -e "Hello\nWorld"` выведет:

```
Hello
World
```

Без параметра `-e`, команда `echo` будет выводить управляющие символы как обычный текст. Например, команда `echo "Hello\nWorld"` выведет:

```
Hello\nWorld
```
# Какие еще системные метрики можно вывести? Что насчёт GPU?
В Linux есть множество системных метрик, которые можно отслеживать. Вот некоторые из них:

1. **Загрузка процессора**: Это можно сделать с помощью команды `top` или `uptime`.
2. **Использование памяти**: Команда `free -h` показывает общее, использованное и свободное пространство в оперативной памяти и swap.
3. **Использование диска**: Команда `df -h` показывает использование дискового пространства для всех подключенных файловых систем.
4. **Состояние сети**: Команды `netstat`, `ss` и `ip` могут быть использованы для отображения различной информации о сетевых соединениях.
5. **Загрузка системы**: Команда `uptime` показывает время работы системы и среднюю загрузку за последние 1, 5 и 15 минут.
6. **Процессы**: Команда `ps` или `top` может быть использована для просмотра информации о работающих процессах.

Что касается GPU, информацию о ней можно получить с помощью различных инструментов, в зависимости от того, какой драйвер и какая видеокарта установлены в вашей системе. Например, если у вас установлен драйвер NVIDIA, вы можете использовать утилиту `nvidia-smi` для отображения информации о GPU. Она может показать такие параметры, как использование GPU, использование памяти, температуру и многое другое.
# Какие ресурсы использует Debian из Microsoft Store?
Если вы используете Debian через Windows Subsystem for Linux (WSL), который доступен в Microsoft Store, то он будет использовать ресурсы вашего компьютера под управлением Windows. Вот некоторые из ресурсов, которые Debian может использовать:

1. **Процессор (CPU)**: Debian будет использовать процессор вашего компьютера для выполнения задач. Количество используемых ресурсов CPU будет зависеть от того, какие задачи вы выполняете.

2. **Оперативная память (RAM)**: Debian будет использовать оперативную память вашего компьютера для хранения временных данных, необходимых для выполнения задач. Как и в случае с CPU, количество используемой памяти будет зависеть от выполняемых задач.

3. **Дисковое пространство**: Debian будет использовать дисковое пространство вашего компьютера для хранения файлов и данных. Объем используемого дискового пространства будет зависеть от того, сколько данных вы сохраняете в Debian.

4. **Сетевые ресурсы**: Debian может использовать сетевые ресурсы вашего компьютера для подключения к Интернету или другим сетям.

Важно отметить, что Debian в WSL не имеет собственного ядра Linux, а вместо этого использует специальный слой совместимости для взаимодействия с ядром Windows. Это означает, что некоторые функции Linux могут быть недоступны или работать не так, как ожидалось.

Вы можете использовать различные инструменты мониторинга системы в Debian и Windows для отслеживания использования этих ресурсов. Например, в Debian вы можете использовать команды `top` или `htop` для мониторинга использования CPU и памяти, а в Windows вы можете использовать "Диспетчер задач" для просмотра общего использования ресурсов системы. 

# <center>Database Administration 101 Course</center>
<img src = 'https://images.spiceworks.com/wp-content/uploads/2023/05/12142314/Shutterstock_1634527660-1.jpg'>
# <center>07 / 01 / 2024 </center>
# Архитектура Oracle Database
При установке базы данных Oracle, сначала устанавливается
программное обеспечение СУБД (Система Управления Базой Данных, 
DataBase Software). Помимо СУБД, необходима также сама база данных. 
Одна система управления базой данных, может работать сразу с 
несколькими базами данных на одном сервере. Каждая такая база 
данных в терминологии Oracle называется экземпляром базы данных 
(DataBase Instance). Каждый запущенный экземпляр активно использует 
ресурсы процессора, оперативной и дисковой памяти.
Далее, мы постепенно разберем что у нас хранится на дисках 
(основные файлы), какие процессы за что отвечают и собственно, что 
хранится в оперативной памяти.
Oracle Database = Oracle DataBase Software + Oracle DataBase 
Instance (s)

# Рассмотрим основные файлы Oracle DataBase.
![image.png](attachment:image.png)

# • Файлы данных (datafiles). 
Все данные в базе данных Oracle сохраняются в файлах данных. Все 
таблицы, индексы, триггеры, последовательности, программы на 
PL/SQL, представления - все это находится в файлах данных. И хотя 
эти и другие объекты базы данных логически содержатся в табличных 
пространствах, в действительности они сохраняются в файлах на 
жестком диске компьютера.
В каждой базе данных Oracle имеется по крайней мере один файл 
данных (но обычно их бывает больше). Если вы создаете в Oracle 
таблицу и заполняете ее строками, Oracle помещает эту таблицу и 
строки в файл данных. Каждый файл данных может быть связан только с 
одной базой данных. Данные в файлы вносятся исключительно 
средствами Oracle.
# • Файлы журнала повторного выполнения (redo log files).
Оперативные файлы журналов повтора - предназначены для записи 
всех изменений, выполненных над данными базы данных Oracle. 
Используется для хранения на диске информации для повторного 
выполнения операций.
Для компьютера выполнить задачи повторно - означает выполнить ее 
точно так, как она выполнялась в предыдущий раз. Поэтому 
назначение оперативного файла журнала повтора заключается в 
сохранении информации об изменениях в базе данных таким, образом, 
чтобы позже их можно было повторить.
Каждая база данных должна иметь не менее двух оперативных файлов 
журналов повтора. Текущий файл постепенно заполняется, после его 
заполнения (или переключения некоторыми командами), база данных 
приступает к записи в следующий файл. Эта операция называется 
переключением журналов.
Поскольку файлы повтора необходимы для выполнения восстановления 
базы данных и являются критичными, их объединяют в группы. Запись 
происходит одновременно в файлы одной группы.
Как только оперативный файл журнала повтора (Redolog) оказывается 
заполнен, программное обеспечение сервера Oracle начинает запись 
в следующий файл. Эта операция повторяется, как следствие 
информация в оперативных файлах журнала (Redolog) многократно 
перезаписывается.
Если необходимо сохранить историю изменений, нужно, чтобы после 
переключения журналов сохранялась их копия. Для этого достаточно 
перевести работу базы данных в режим работы ARCHIVELOG.
Архивные файлы журналов повтора жизненно важны при 
восстановлении. Если часть базы данных потеряна или повреждена, 
то для устранения повреждений обычно требуется несколько архивных 
журналов или туева хуча этих журналов. Файлы журналов повтора 
должны применяться к базе данных последовательно. Если один из 
архивных файлов журналов повтора пропущен, то остальные архивные 
файлы журналов не могут использоваться. Храните все свои архивные 
файлы журналов повтора с момента выполнения последней резервной 
копии. Файлы журналов постепенно накапливаются и разрастаются. 
Иногда необходимо их удалять. Все операции с данными файлами по 
применению их к базе выполняются исключительно средствами базы 
данных. А копировать и переносить их при желании можно как 
угодно. Бездумно удалять их руками не рекомендуется.
# • Управляющие файлы (control files).
Поскольку база данных Oracle является физическим набором 
связанных файлов данных, то для их синхронизации и контроля 
требуется особые методы. Для этих целей используются управляющие 
файлы. Иными словам, этот сравнительно небольшой файл (в редких 
случаях он может увеличиваться до 64 Мбайт), содержащий 
информацию обо всех файлах, необходимых серверу Oracle.
База данных Oracle может иметь один или несколько управляющих 
файлов. Если имеется несколько управляющих файлов, все они должны 
быть абсолютно идентичными. При каждом запуске базы данных Oracle 
читает информацию управляющего файла, а при каждом изменении 
размещения или добавления новых файлов данных и журналов базы 
данных обновляет управляющий файл.
Необходимо поддерживать несколько копий управляющих файлов, 
желательно на разных дисках, чтобы предотвратить потерю 
управляющих файлов в случае сбоя диска. Потеря управляющих файлов 
— не фатальное событие, она только существенно усложнит 
восстановление.
# • Временные файлы (temp files).
Сервер Oracle использует временные файлы для хранения промежуточных 
результатов сортировки большого объема данных или результирующих 
множеств, если для них не хватает оперативной памяти.
# • Файлы параметров.
Файлы параметров используются для конфигурирования действий 
Oracle прежде всего при старте. Для того, чтобы запустить 
экземпляр базы данных, Oracle должен прочесть файл параметров и 
определить, какие параметры инициализации установлены для этого 
экземпляра. В файле параметров содержатся многочисленные 
параметры и их установленные значения. Oracle считывает файл 
параметров при запуске базы данных. Можно создать несколько 
файлов параметров, каждый будет соответствовать различным 
конфигурациям экземпляра.
spfile - бинарный файл, который используется сервером Oracle при 
старте.
pfile - текстовый файл с параметрами, будет использоваться при 
старте, если не будет найден spfile.
# Процессы Oracle DataBase.
Есть обязательные процессы, без которых oracle работать не сможет и 
необязательные. Процесс, отвечающий за подключение к базе данных и 
для работы пользователя с ней - не является обязательным.
Обязательные процессы запускаются при старте экземпляра и остаются 
активными на все время его жизни.
Далее перечислим наиболее важные процессы:
• DBWn (DataBase Writer) - записывает модифицированные данные из 
буферного кэша в файлы данных
• LGWR (Log Writer) - записывает содержимое redolog буфера в 
redolog файлы.
• ARCn (Archiver) – архивирует заполненные redolog журналы если 
такая опция включена. Не является обязательным. Жрет доп. 
ресурсы. Зато можно восстановить базу к любому времени когда 
эта опция включена. (упрощенно)
• CKPT (checkpoint) – отвечает за создание контрольных точек
• PMON (Process Monitor) – мониторит процессы и восстанавливает 
работу процессов в случае их сбоя
• SMON (System Monitor) – отвечает за восстановление системы в 
случае сбоев
• MMON (manageability monitor) - сбор статистики
# Задание на 07 / 01 / 2024
## Процесс установки
Перед установкой.

Под root или администратором:
sudo yum install -y oracle-database-preinstall-19c
passwd oracle
mkdir -p /u01/app/oracle/product/19.0.0/dbhome_1
chown -R oracle:oinstall /u01
chmod -R 775 /u01
mv DATABASE_INSTALLATION.zip /home/oracle
chmod 777 /home/oracle/DATABASE_INSTALLATION.zip 

Меняем пользователя на oracle
su - oracle
cd /u01/app/oracle/product/19.0.0/dbhome_1
unzip DATABASE_INSTALLATION.zip -d /home/oracle/install
cd /home/oracle/install

Установка софта СУБД.
./runInstaller

Установка переменных окружения.
В файле /home/oracle/.bash_profile прописываем переменные
export ORACLE_BASE=/u01/app/oracle
export ORACLE_HOME=$ORACLE_BASE/product/19.0.0/dbhome_1
export ORACLE_SID=ИМЯ_ВАШЕЙ_БД

export PATH=$ORACLE_HOME/bin:$PATH
Выходим из файла, сохранив изменения.

Применяем настройки:
. /home/oracle/.bash_profile

Запускаем установку инстанции БД
dbca

После установки.

sqlplus system/system
create user USERNAME identified by PASSWORD;
grant dba to USERNAME;
conn USERNAME/PASSWORD

создать таблицу и вставить туда данные
# Как изменить пароль пользователя system?
Чтобы изменить пароль пользователя system, необходимо выполнить следующую команду:

```sql
ALTER USER system IDENTIFIED BY new_password;
```

Например, чтобы изменить пароль на "new_password", необходимо выполнить следующую команду:

```sql
ALTER USER system IDENTIFIED BY new_password;
```

После выполнения этой команды необходимо перезапустить экземпляр базы данных, чтобы изменения вступили в силу.

Если вы не знаете старый пароль пользователя system, вы можете выполнить следующую команду, чтобы сбросить его:

```sql
ALTER USER system IDENTIFIED BY DEFAULT;
```

Эта команда сбросит пароль пользователя system на значение по умолчанию, которое указано в файле паролей базы данных.

Чтобы узнать значение пароля по умолчанию, можно выполнить следующую команду:

```sql
SELECT * FROM SYS.USER$ WHERE USERNAME = 'system';
```

Эта команда выведет информацию о пользователе system, включая его пароль по умолчанию.

После того, как вы сменили или сбросили пароль пользователя system, вы сможете снова подключиться к базе данных, используя новый пароль.
# Задание
- ### Создать нового пользователя в БД под именем student.

**Создание пользователя student**

```sql
SQL> CREATE USER student IDENTIFIED BY student;
```
- ### Дать student-у права на создание сессии, создание таблицы, заполнение таблицы.

**Предоставление прав student-у**

```sql
SQL> GRANT CREATE SESSION TO student;
SQL> GRANT CREATE TABLE TO student;
SQL> GRANT INSERT ANY TABLE TO student;
SQL> ALTER USER student QUOTA UNLIMITED ON USERS;
```
- ### Под student-ом создать таблицу и заполнить любым количеством данных.

**Создание таблицы под student-ом**

```sql
SQL> CREATE TABLE students (
  id NUMBER(10) NOT NULL,
  name VARCHAR2(255) NOT NULL,
  age NUMBER(10) NOT NULL
);
```

**Заполнение таблицы данными**

```sql
SQL> INSERT INTO students (id, name, age) VALUES (1, 'John Doe', 20);
SQL> INSERT INTO students (id, name, age) VALUES (2, 'Jane Doe', 22);
SQL> INSERT INTO students (id, name, age) VALUES (3, 'John Smith', 25);
```

**Вывод данных из таблицы**

```sql
SQL> SELECT * FROM students;
```

**Результат:**

```
ID NAME AGE
---------- ---------- ----------
1 John Doe 20
2 Jane Doe 22
3 John Smith 25
```

**Комментарии:**

* Для создания пользователя необходимо указать имя пользователя и пароль.
* Для предоставления прав пользователю необходимо использовать команду GRANT.
* Для создания таблицы необходимо использовать команду CREATE TABLE.
* Для заполнения таблицы данными необходимо использовать команду INSERT.
* Для вывода данных из таблицы необходимо использовать команду SELECT.
# Как удалить пользователя system?
Чтобы удалить пользователя system, необходимо выполнить следующую команду:

```sql
DROP USER system CASCADE;
```

Эта команда удалит пользователя system, а также все его объекты, включая таблицы, представления, хранимые процедуры и т.д.

Если вы не хотите удалять все объекты пользователя system, вы можете выполнить следующую команду, чтобы удалить только самого пользователя:

```sql
DROP USER system;
```

Эта команда удалит пользователя system, но не удалит его объекты.

Перед удалением пользователя system необходимо убедиться, что у вас есть резервная копия базы данных. Это необходимо для того, чтобы в случае необходимости вы могли восстановить пользователя system.

Вот пошаговая инструкция по удалению пользователя system:

1. Подключитесь к базе данных как пользователь с привилегиями DBA.
2. Выполните команду DROP USER system CASCADE.
3. Перезапустите экземпляр базы данных.

Вот пример выполнения команды DROP USER system CASCADE:

```sql
SQL> conn / as sysdba
Connected.

SQL> DROP USER system CASCADE;
User dropped.

SQL> exit
Disconnected from Oracle Database 12c Enterprise Edition Release 12.2.0.1.0 - 64bit Production
```

После выполнения этой команды пользователь system будет удален из базы данных.
# <center>16 / 01 / 2024</center>
# Запуск и остановка БД
- STARTUP NOMOUNT
- STARTUP MOUNT
- STARTUP OPEN

Изначально >SQL: startup стоит на startup open

- SHUTDOWN NORMAL - завершает все процессы
- SHUTDOWN IMMEDIATE - немедленное завершение
- SHOTDOWN ABORT - прерывание всех процессов, после него нужно делать восстановление БД

Изначально shutdown = shutdown normal

# Что такое табличные пространства?
- Логическая сущность, содержащая физические БД.
- Хранят все БД, и эти данные в табличных пространствах физически хранятся в одном или более файле данных.

По умолчанию есть 5 табличных пространств
- System
- Sysaux и System хранят компоненты БД
- Undo хранит redo лог
- Temporary - временные файлы
- Постоянноe tablespace по умолчанию (User)
# Что такое Oracle Network Configuration? 
- В самом базовом виде Oracle использует три файла конфигурации сети:
    - listener.ora
    - tnsnames.ora
    - sql.ora

# <center>19 / 01 / 2024 </center>
# Какие бывают расширения файлов в Oracle Database и за что они отвечают?
1. Файлы данных (Datafiles) - имеют расширение .dbf (Data Base File).
2. Файлы журналов (Redo Log Files) - имеют расширение .log.
3. Файлы управления (Control Files) - могут иметь любое расширение, но обычно используется .ctl.
4. Файлы параметров (Parameter Files) - могут иметь любое расширение, но обычно используется .ora.
5. Файлы архивных журналов (Archive Log Files) - имеют расширение .arc.
6. Файлы временных таблиц (Temporary Files) - могут иметь любое расширение, но обычно используется .tmp.
# Что такое listener?
Listener в Oracle Database - это процесс, который работает на сервере базы данных. Он принимает входящие запросы на подключение от клиентов и управляет трафиком запросов. Конфигурационная информация слушателя хранится в файле listener.ora и включает один или несколько протокольных адресов, информацию о поддерживаемых службах и параметры, которые контролируют его поведение во время выполнения [Source 2](https://docs.oracle.com/en/database/oracle/oracle-database/manage-listener-utility/index.html).

Когда клиентская заявка приходит, слушатель сначала ее получает. Затем слушатель устанавливает соединение между клиентом и экземпляром базы данных. Как только клиент успешно подключается к экземпляру базы данных, слушатель передает соединение с клиентом серверному процессу [Source 4](https://www.oracletutorial.com/oracle-administration/oracle-listener/).

Если слушатель перестает работать, вы не сможете подключиться к Oracle Database. Однако существующие соединения не затрагиваются.

Слушатель конфигурируется во время создания базы данных. После конфигурации вы можете использовать слушатель управления для управления слушателем [Source 2](https://docs.oracle.com/en/database/oracle/oracle-database/manage-listener-utility/index.html).
# Что такое экземпляр базы данных и с чем его часто путают?
Экземпляр базы данных в Oracle - это активный процесс, который управляет доступом к определенной базе данных. Когда вы устанавливаете Oracle Database, вы устанавливаете программное обеспечение СУБД (системы управления базой данных) и саму базу данных. Одна система управления базой данных может работать с несколькими базами данных на одном сервере. Каждая такая база данных в терминологии Oracle называется экземпляром базы данных [Source 0](https://oracle-dba.ru/docs/architecture/instance/).

Каждый запущенный экземпляр активно использует ресурсы процессора, оперативной и дисковой памяти. Для того чтобы узнать текущее состояние экземпляра базы данных, можно выполнить следующую процедуру: убедиться, что подключаетесь к базе с правильным параметром ORACLE_SID. Далее, можно выполнить команду `export ORACLE_SID=ora112` для изменения SID, и команды `echo $ORACLE_SID` и `sqlplus / as sysdba` для проверки статуса экземпляра [Source 0](https://oracle-dba.ru/docs/architecture/instance/).

Экземпляр базы данных часто путают с сам базой данных. Однако, они являются разными понятиями. База данных - это физическая структура, которая содержит данные и метаданные. Экземпляр базы данных - это активный процесс, который управляет доступом к базе данных и использует ресурсы системы [Source 1](https://oracle-dba.ru/database/installation/single-instance/simple/linux/6.7/oracle/12.1/oracle-instance-creation/).
# Финальное задание
>- #### 1.5. Подключиться к новой базе данных test101 по SQLDeveloper-у. Задача – создать нового пользователя admin с правами администратора, заблокировав sys и system.
Для выполнения этих задач вам потребуется использовать SQL*Plus или SQL Developer. Ниже приведены шаги, которые вам нужно выполнить:

1. Откройте SQL*Plus или SQL Developer и подключитесь к базе данных `test101` как `SYSDBA`.

2. Создайте нового пользователя `admin` с правами администратора. Вы можете сделать это с помощью следующего SQL-запроса:

   ```sql
   CREATE USER admin IDENTIFIED BY admin_password;
   GRANT DBA TO admin;
   ```
   Здесь `admin_password` - это пароль, который вы хотите установить для пользователя `admin`.

3. Заблокируйте учетные записи `sys` и `system`. Это можно сделать с помощью следующих SQL-запросов:

   ```sql
   ALTER USER sys ACCOUNT LOCK;
   ALTER USER system ACCOUNT LOCK;
   ```
>- #### 1.6. Под admin создать нового пользователя final_user, дать ему права на подключение к БД, создание таблиц и процедур, а также неограниченный доступ к тейблспейсу users.
4. Теперь переключитесь на пользователя `admin` и создайте нового пользователя `final_user`. Вы можете сделать это с помощью следующего SQL-запроса:

   ```sql
   CREATE USER final_user IDENTIFIED BY final_user_password DEFAULT TABLESPACE users QUOTA UNLIMITED ON users;
   GRANT CONNECT, RESOURCE, CREATE PROCEDURE TO final_user;
   ```
   Здесь `final_user_password` - это пароль, который вы хотите установить для пользователя `final_user`.


[Source 1](https://www.atlassian.com/data/admin/how-to-create-a-user-and-grant-permissions-in-oracle) и [Source 3](https://docs.oracle.com/en/database/oracle/oracle-database/19/tutorial-create-sql-developer-account/index.html) предоставляют дополнительную информацию о том, как создавать пользователей и предоставлять им права в Oracle.
>- #### 2.1. Создать скрипт, который будет собирать данные о состоянии БД и листенера и выводить эти данные на экран.
>- #### 2.2. Также скрипт должен показывать где находится папка с БД и имя БД.
Ваш скрипт на bash, который собирает данные о состоянии базы данных и слушателя, а также о местоположении базы данных и ее имени, может выглядеть так:

```bash
#!/bin/bash

# Получаем имя экземпляра базы данных
dbInstanceName=$(sqlplus -s / as sysdba <<EOF
SET PAGESIZE 0 FEEDBACK OFF VERIFY OFF HEADING OFF ECHO OFF
SELECT name FROM v\$database;
EXIT;
EOF)

# Получаем путь к директории базы данных
dbDirectory=$(sqlplus -s / as sysdba <<EOF
SET PAGESIZE 0 FEEDBACK OFF VERIFY OFF HEADING OFF ECHO OFF
SELECT value FROM v\$parameter WHERE name = 'db_create_file_dest';
EXIT;
EOF)

# Получаем состояние базы данных и сохраняем его в переменной databaseStatus
databaseStatus=$(echo "select instance_name, status, database_status from v\$instance;" | sqlplus -s / as sysdba)

# Получаем состояние слушателя Oracle и сохраняем его в переменной listenerStatus
listenerStatus=$(lsnrctl status)

# Выводим информацию о базе данных
echo "Database Instance Name: $dbInstanceName"
echo "Database Directory: $dbDirectory"
echo "Database Status:"
echo "$databaseStatus"
echo "Listener Status:"
echo "$listenerStatus"
```

Этот скрипт сначала получает имя экземпляра базы данных и путь к директории базы данных с помощью SQL-запросов к системным представлениям Oracle. Затем он получает состояние базы данных и слушателя Oracle и выводит их на экран.

Обратите внимание, что этот скрипт требует, чтобы на сервере была установлена утилита sqlplus и что у вас есть права на выполнение SQL-запросов к базе данных.

[Source 1](https://dbaclass.com/monitor-your-db/) и [Source 4](https://docs.oracle.com/en/database/oracle/oracle-database/manage-listener-utility/index.html?opt-release-19c) предоставляют дополнительную информацию о том, как получить информацию о базе данных и слушателе Oracle.
# Как в SQL объявить переменную?
В SQL переменные объявляются с помощью ключевого слова `DECLARE`. Синтаксис объявления переменной в SQL выглядит следующим образом:

```sql
DECLARE @variable_name datatype;
```

Здесь `@variable_name` - это имя переменной, а `datatype` - это тип данных переменной. Имя переменной должно начинаться с символа `@`.

Например, для объявления переменной `myVar` типа `varchar` вы можете использовать следующий код:

```sql
DECLARE @myVar varchar(50);
```

Вы также можете объявить несколько переменных в одной строке, разделяя их запятыми:

```sql
DECLARE @firstName varchar(50), @lastName varchar(50), @age int;
```

После объявления переменной, вы можете присвоить ей значение с помощью оператора `=` или `SET`. Например:

```sql
SET @myVar = 'Hello, World!';
```

или

```sql
@myVar = 'Hello, World!';
```

[Source 0](https://www.sqlshack.com/sql-variables-basics-and-usage/), [Source 1](https://learn.microsoft.com/en-us/sql/t-sql/language-elements/variables-transact-sql?view=sql-server-ver16), [Source 3](https://www.mssqltips.com/sqlservertip/7755/sql-declare-variable-code-examples/) предоставляют дополнительную информацию о том, как объявлять и использовать переменные в SQL.
# Как объявить переменную в Linux?
В скриптах Linux переменные объявляются без указания типа данных, как это делается в некоторых других языках программирования. Для объявления переменной в скрипте bash вы просто присваиваете ей значение с помощью оператора `=`. Например:

```bash
variable="value"
```

В этом примере `variable` - это имя переменной, а `"value"` - это значение, которое мы присваиваем этой переменной.

Вы также можете объявить несколько переменных в одной строке, разделяя их пробелами:

```bash
var1="value1" var2="value2" var3="value3"
```

Вы можете использовать значение переменной, обращаясь к ней с помощью символа `$`. Например:

```bash
echo $variable
```

Эта команда выведет значение переменной `variable` на экран.

[Source 1](https://www.opennet.ru/docs/RUS/bash_scripting_guide/x1673.html), [Source 2](https://basis.gnulinux.pro/ru/latest/basis/13/13._bash_%E2%84%962%3A_%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5.html), [Source 4](https://ru.hexlet.io/blog/posts/bash-export) предоставляют дополнительную информацию о том, как объявлять и использовать переменные в скриптах bash.